var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));

// ../../node_modules/.pnpm/tsup@5.12.9/node_modules/tsup/assets/esm_shims.js
var init_esm_shims = __esm({
  "../../node_modules/.pnpm/tsup@5.12.9/node_modules/tsup/assets/esm_shims.js"() {
  }
});

// ../../node_modules/.pnpm/cookie@0.5.0/node_modules/cookie/index.js
var require_cookie = __commonJS({
  "../../node_modules/.pnpm/cookie@0.5.0/node_modules/cookie/index.js"(exports) {
    "use strict";
    init_esm_shims();
    exports.parse = parse3;
    exports.serialize = serialize3;
    var __toString = Object.prototype.toString;
    var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
    function parse3(str, options) {
      if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
      }
      var obj = {};
      var opt = options || {};
      var dec = opt.decode || decode;
      var index = 0;
      while (index < str.length) {
        var eqIdx = str.indexOf("=", index);
        if (eqIdx === -1) {
          break;
        }
        var endIdx = str.indexOf(";", index);
        if (endIdx === -1) {
          endIdx = str.length;
        } else if (endIdx < eqIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        var key = str.slice(index, eqIdx).trim();
        if (obj[key] === void 0) {
          var val = str.slice(eqIdx + 1, endIdx).trim();
          if (val.charCodeAt(0) === 34) {
            val = val.slice(1, -1);
          }
          obj[key] = tryDecode(val, dec);
        }
        index = endIdx + 1;
      }
      return obj;
    }
    function serialize3(name, val, options) {
      var opt = options || {};
      var enc = opt.encode || encode;
      if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
      }
      if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
      }
      var value = enc(val);
      if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
      }
      var str = name + "=" + value;
      if (opt.maxAge != null) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
          throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
      }
      if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
          throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
      }
      if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
          throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
      }
      if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
          throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
      }
      if (opt.httpOnly) {
        str += "; HttpOnly";
      }
      if (opt.secure) {
        str += "; Secure";
      }
      if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError("option priority is invalid");
        }
      }
      if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch (sameSite) {
          case true:
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError("option sameSite is invalid");
        }
      }
      return str;
    }
    function decode(str) {
      return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
    }
    function encode(val) {
      return encodeURIComponent(val);
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]" || val instanceof Date;
    }
    function tryDecode(str, decode2) {
      try {
        return decode2(str);
      } catch (e) {
        return str;
      }
    }
  }
});

// src/index.ts
init_esm_shims();

// src/supabase-browser.ts
init_esm_shims();
var import_cookie = __toESM(require_cookie());
import { createClient } from "@supabase/supabase-js";

// src/utils/helpers.ts
init_esm_shims();
function ensureArray(data) {
  return Array.isArray(data) ? data : [data];
}
function isBrowser() {
  return typeof window !== "undefined";
}

// src/supabase-browser.ts
function createBrowserSupabaseClient({
  supabaseUrl,
  supabaseKey,
  options,
  cookieOptions: {
    name = "supabase-auth-token",
    domain,
    path = "/",
    sameSite = "lax",
    secure,
    maxAge = 1e3 * 60 * 60 * 24 * 365
  } = {}
}) {
  return createClient(supabaseUrl, supabaseKey, __spreadProps(__spreadValues({}, options), {
    auth: {
      storageKey: name,
      storage: {
        getItem(key) {
          if (!isBrowser()) {
            return null;
          }
          const cookies = (0, import_cookie.parse)(document.cookie);
          return cookies[key] || null;
        },
        setItem(key, _value) {
          var _a;
          if (!isBrowser()) {
            return;
          }
          let session = JSON.parse(_value);
          delete session.user.identities;
          const value = JSON.stringify(session);
          document.cookie = (0, import_cookie.serialize)(key, value, {
            domain,
            path,
            maxAge,
            httpOnly: false,
            sameSite,
            secure: secure != null ? secure : ((_a = document.location) == null ? void 0 : _a.protocol) === "https:"
          });
        },
        removeItem(key) {
          if (!isBrowser()) {
            return;
          }
          document.cookie = (0, import_cookie.serialize)(key, "", {
            domain,
            path,
            expires: new Date(0),
            httpOnly: false,
            sameSite,
            secure
          });
        }
      }
    }
  }));
}

// src/supabase-server.ts
init_esm_shims();
import { createClient as createClient2 } from "@supabase/supabase-js";

// src/utils/cookies.ts
init_esm_shims();
var import_cookie2 = __toESM(require_cookie());
function filterCookies(cookies, key) {
  const indexes = new Set(cookies.map((cookie) => (0, import_cookie2.parse)(cookie)).reduce((acc, cookie, i) => {
    if (key in cookie) {
      acc.push(i);
    }
    return acc;
  }, new Array()));
  return cookies.filter((_, i) => !indexes.has(i));
}
function isSecureEnvironment(headerHost) {
  if (!headerHost) {
    throw new Error('The "host" request header is not available');
  }
  const headerHostStr = Array.isArray(headerHost) ? headerHost[0] : headerHost;
  const host = headerHostStr.indexOf(":") > -1 && headerHostStr.split(":")[0] || headerHostStr;
  if (["localhost", "127.0.0.1"].indexOf(host) > -1 || host.endsWith(".local")) {
    return false;
  }
  return true;
}

// src/supabase-server.ts
function createServerSupabaseClient({
  supabaseUrl,
  supabaseKey,
  getCookie,
  setCookie,
  getRequestHeader,
  options,
  cookieOptions: {
    name = "supabase-auth-token",
    domain,
    path = "/",
    sameSite = "lax",
    secure,
    maxAge = 1e3 * 60 * 60 * 24 * 365
  } = {}
}) {
  var _a;
  let currentSessionStr = (_a = getCookie(name)) != null ? _a : null;
  return createClient2(supabaseUrl, supabaseKey, __spreadProps(__spreadValues({}, options), {
    auth: {
      detectSessionInUrl: false,
      autoRefreshToken: false,
      storageKey: name,
      storage: {
        getItem(key) {
          return currentSessionStr;
        },
        setItem(key, _value) {
          let session = JSON.parse(_value);
          delete session.user.identities;
          const value = JSON.stringify(session);
          if (currentSessionStr === value) {
            return;
          }
          currentSessionStr = value;
          setCookie(key, value, {
            domain,
            path,
            maxAge,
            httpOnly: false,
            sameSite,
            secure: secure != null ? secure : isSecureEnvironment(getRequestHeader("host"))
          });
        },
        removeItem(key) {
          if (!currentSessionStr) {
            return;
          }
          setCookie(key, "", {
            domain,
            path,
            expires: new Date(0),
            httpOnly: false,
            sameSite,
            secure: secure != null ? secure : isSecureEnvironment(getRequestHeader("host"))
          });
        }
      }
    }
  }));
}

// src/types.ts
init_esm_shims();

// src/utils/index.ts
init_esm_shims();

// src/utils/errors.ts
init_esm_shims();
var AuthHelperError = class extends Error {
  constructor(message, errorType) {
    super(message);
    this.errorType = errorType;
    this.source = "sb_auth_helpers";
  }
  toObj() {
    return {
      type: this.errorType,
      message: this.message,
      source: this.source
    };
  }
  toString() {
    return JSON.stringify(this.toObj());
  }
};
var CookieNotFound = class extends AuthHelperError {
  constructor() {
    super("No cookie was found!", "cookie_not_found");
  }
};
var CookieNotSaved = class extends AuthHelperError {
  constructor() {
    super("Cookies cannot be saved!", "cookie_not_saved");
  }
};
var AccessTokenNotFound = class extends AuthHelperError {
  constructor() {
    super("No access token was found!", "cookie_not_found");
  }
};
var RefreshTokenNotFound = class extends AuthHelperError {
  constructor() {
    super("No refresh token was found!", "cookie_not_found");
  }
};
var ProviderTokenNotFound = class extends AuthHelperError {
  constructor() {
    super("No provider token was found!", "cookie_not_found");
  }
};
var CookieNotParsed = class extends AuthHelperError {
  constructor() {
    super("Not able to parse cookies!", "cookie_not_parsed");
  }
};
var CallbackUrlFailed = class extends AuthHelperError {
  constructor(callbackUrl) {
    super(`The request to ${callbackUrl} failed!`, "callback_url_failed");
  }
};
var JWTPayloadFailed = class extends AuthHelperError {
  constructor() {
    super("Not able to parse JWT payload!", "jwt_payload_failed");
  }
};
var JWTInvalid = class extends AuthHelperError {
  constructor() {
    super("Invalid jwt!", "jwt_invalid");
  }
};
var export_parseCookies = import_cookie2.parse;
var export_serializeCookie = import_cookie2.serialize;
export {
  AccessTokenNotFound,
  AuthHelperError,
  CallbackUrlFailed,
  CookieNotFound,
  CookieNotParsed,
  CookieNotSaved,
  JWTInvalid,
  JWTPayloadFailed,
  ProviderTokenNotFound,
  RefreshTokenNotFound,
  createBrowserSupabaseClient,
  createServerSupabaseClient,
  ensureArray,
  filterCookies,
  isBrowser,
  export_parseCookies as parseCookies,
  export_serializeCookie as serializeCookie
};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
//# sourceMappingURL=index.mjs.map